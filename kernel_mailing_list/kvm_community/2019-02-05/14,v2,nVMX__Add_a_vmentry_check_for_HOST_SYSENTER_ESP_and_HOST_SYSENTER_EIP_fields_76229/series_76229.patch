From patchwork Tue Feb  5 22:34:24 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Krish Sadhukhan <krish.sadhukhan@oracle.com>
X-Patchwork-Id: 10798649
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 328471390
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:39 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 22EBD2C54B
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:39 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 14C992C59A; Tue,  5 Feb 2019 22:59:39 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI,
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B94D12C54B
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1730536AbfBEW7h (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 5 Feb 2019 17:59:37 -0500
Received: from aserp2130.oracle.com ([141.146.126.79]:33142 "EHLO
        aserp2130.oracle.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1729312AbfBEW7f (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 5 Feb 2019 17:59:35 -0500
Received: from pps.filterd (aserp2130.oracle.com [127.0.0.1])
        by aserp2130.oracle.com (8.16.0.27/8.16.0.27) with SMTP id
 x15MxCZc072945;
        Tue, 5 Feb 2019 22:59:29 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com;
 h=from : to : cc :
 subject : date : message-id : in-reply-to : references; s=corp-2018-07-02;
 bh=MN2oeakJHtM76Zvz6JslISrjBvSwt/tHp1ALChQanFw=;
 b=3/n+Ebk8t7YdEXosOiIFgOBZ/dsaitNWAHid/BWPKw2nWEXVPdPSjTvidWORc6dz0zVI
 uJLgTEn5W95xAgBbcJtL5j/ndbRpnOIYxXvQK+IR6qDQIRicOYYCGWK4hv0i8HU4ROO1
 Mf1SoCWIsjH3CnlMzZKQ5Nk0lm66kTp47/glP8AuwlfLaOJ4sk47GVWOuVijYWTX2mup
 8BSbj99iqbuw2/F6y9IQxgiQT/fGFyoUdj8GEVsW/tZhBTafKHhQL6qD39C5XNJvznTE
 6h3hVNUYyP6LDtiiZX2YQ+95hx+3Z8yz35pr7M+Y8AX+oaI29rsFKKc3gFxFlD45E30u Qw==
Received: from aserv0021.oracle.com (aserv0021.oracle.com [141.146.126.233])
        by aserp2130.oracle.com with ESMTP id 2qd97ex0sm-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 05 Feb 2019 22:59:29 +0000
Received: from aserv0122.oracle.com (aserv0122.oracle.com [141.146.126.236])
        by aserv0021.oracle.com (8.14.4/8.14.4) with ESMTP id x15MxOLF002346
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 5 Feb 2019 22:59:24 GMT
Received: from abhmp0004.oracle.com (abhmp0004.oracle.com [141.146.116.10])
        by aserv0122.oracle.com (8.14.4/8.14.4) with ESMTP id x15MxO2K016088;
        Tue, 5 Feb 2019 22:59:24 GMT
Received: from ban25x6uut29.us.oracle.com (/10.153.73.29)
        by default (Oracle Beehive Gateway v4.0)
        with ESMTP ; Tue, 05 Feb 2019 22:59:24 +0000
From: Krish Sadhukhan <krish.sadhukhan@oracle.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, jmattson@google.com
Subject: [PATCH 1/4 v2][KVM nVMX]: Add a vmentry check for HOST_SYSENTER_ESP
 and HOST_SYSENTER_EIP fields
Date: Tue,  5 Feb 2019 17:34:24 -0500
Message-Id: <20190205223427.7387-2-krish.sadhukhan@oracle.com>
X-Mailer: git-send-email 2.17.2
In-Reply-To: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
References: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
X-Proofpoint-Virus-Version: vendor=nai engine=5900 definitions=9158
 signatures=668682
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0
 priorityscore=1501 malwarescore=0
 suspectscore=1 phishscore=0 bulkscore=0 spamscore=0 clxscore=1015
 lowpriorityscore=0 mlxscore=0 impostorscore=0 mlxlogscore=626 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.0.1-1810050000
 definitions=main-1902050168
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

According to section "Checks on VMX Controls" in Intel SDM vol 3C, the
following check is performed on vmentry of L2 guests:

    On processors that support Intel 64 architecture, the IA32_SYSENTER_ESP
    field and the IA32_SYSENTER_EIP field must each contain a canonical
    address.

Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
Reviewed-by: Mihai Carabas <mihai.carabas@oracle.com>
Reviewed-by: Jim Mattson <jmattson@google.com>
---
 arch/x86/kvm/vmx/nested.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.c
index 7bb5e565f3fa..47c28422903c 100644
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@ -2595,6 +2595,11 @@ static int nested_check_host_control_regs(struct kvm_vcpu *vcpu,
 	    !nested_host_cr4_valid(vcpu, vmcs12->host_cr4) ||
 	    !nested_cr3_valid(vcpu, vmcs12->host_cr3))
 		return -EINVAL;
+
+	if (is_noncanonical_address(vmcs12->host_ia32_sysenter_esp, vcpu) ||
+	    is_noncanonical_address(vmcs12->host_ia32_sysenter_eip, vcpu))
+		return -EINVAL;
+
 	/*
 	 * If the load IA32_EFER VM-exit control is 1, bits reserved in the
 	 * IA32_EFER MSR must be 0 in the field for that register. In addition,

From patchwork Tue Feb  5 22:34:25 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Krish Sadhukhan <krish.sadhukhan@oracle.com>
X-Patchwork-Id: 10798643
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 371B31390
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 27D002C54B
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1C96B2C583; Tue,  5 Feb 2019 22:59:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI,
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C1F9D2C5AD
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1729963AbfBEW7c (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 5 Feb 2019 17:59:32 -0500
Received: from userp2130.oracle.com ([156.151.31.86]:39940 "EHLO
        userp2130.oracle.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727501AbfBEW7b (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 5 Feb 2019 17:59:31 -0500
Received: from pps.filterd (userp2130.oracle.com [127.0.0.1])
        by userp2130.oracle.com (8.16.0.27/8.16.0.27) with SMTP id
 x15MxEe6067631;
        Tue, 5 Feb 2019 22:59:25 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com;
 h=from : to : cc :
 subject : date : message-id : in-reply-to : references; s=corp-2018-07-02;
 bh=RVbAIRkixKNG6gsuYpLxf8Ay7QQILTBkHkOmUDPDCXA=;
 b=CUXYMtw1z4yh/Enh7zsxW9Mx7aONFK1QD82O1Q2P+VN/QxZQE5bU6zLTq3wHGPV6oZSR
 m+NrzCrMMQ0HTxGJ7WIPV4XeD7Iuzlh5u2NxnJkIZoAkUS8PC421fSFLS9jOKm7OPXz0
 CZfHhcFdNCt2vX6+uQZ23ECXd7XGVeGaeIlHrhpfHnGEOI+LBmwBebkPrQjwS6/koN5M
 0EIOeeWEGktmWVcjHrAzzIQqSVcW6DYBALrmaKYpUry+3bXlHBorsr0r3mcuLJA9HnUp
 jkPOMTGR4q1ZY8wZpG31BYJV+cDeSuJL1Ik/rF2Hb9hAUtkNTBxKMggUBMaquhOagwpM HA==
Received: from userv0022.oracle.com (userv0022.oracle.com [156.151.31.74])
        by userp2130.oracle.com with ESMTP id 2qd9are16c-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 05 Feb 2019 22:59:25 +0000
Received: from aserv0121.oracle.com (aserv0121.oracle.com [141.146.126.235])
        by userv0022.oracle.com (8.14.4/8.14.4) with ESMTP id x15MxOfe010784
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 5 Feb 2019 22:59:25 GMT
Received: from abhmp0004.oracle.com (abhmp0004.oracle.com [141.146.116.10])
        by aserv0121.oracle.com (8.14.4/8.13.8) with ESMTP id x15MxOfR016502;
        Tue, 5 Feb 2019 22:59:24 GMT
Received: from ban25x6uut29.us.oracle.com (/10.153.73.29)
        by default (Oracle Beehive Gateway v4.0)
        with ESMTP ; Tue, 05 Feb 2019 22:59:24 +0000
From: Krish Sadhukhan <krish.sadhukhan@oracle.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, jmattson@google.com
Subject: [PATCH 2/4 v2][kvm-unit-test nVMX]: Move test_vm_entry_ctls() below
 test_vm_exit_ctls()
Date: Tue,  5 Feb 2019 17:34:25 -0500
Message-Id: <20190205223427.7387-3-krish.sadhukhan@oracle.com>
X-Mailer: git-send-email 2.17.2
In-Reply-To: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
References: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
X-Proofpoint-Virus-Version: vendor=nai engine=5900 definitions=9158
 signatures=668682
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0
 priorityscore=1501 malwarescore=0
 suspectscore=1 phishscore=0 bulkscore=0 spamscore=0 clxscore=1015
 lowpriorityscore=0 mlxscore=0 impostorscore=0 mlxlogscore=909 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.0.1-1810050000
 definitions=main-1902050168
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

.. to align the checks according to the order in Intel SDM.

Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
Reviewed-by: Jim Mattson <jmattson@google.com>
---
 x86/vmx_tests.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index ee0c9ff..9a3cdee 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -4923,8 +4923,8 @@ static void vmx_controls_test(void)
 	vmcs_write(GUEST_RFLAGS, 0);
 
 	test_vm_execution_ctls();
-	test_vm_entry_ctls();
 	test_vm_exit_ctls();
+	test_vm_entry_ctls();
 }
 
 static bool valid_vmcs_for_vmentry(void)

From patchwork Tue Feb  5 22:34:26 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Krish Sadhukhan <krish.sadhukhan@oracle.com>
X-Patchwork-Id: 10798647
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 2580313B4
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:38 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 148BB2C583
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:38 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 08B3E2C61E; Tue,  5 Feb 2019 22:59:38 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI,
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 82C1A2C583
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1730513AbfBEW7f (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 5 Feb 2019 17:59:35 -0500
Received: from userp2130.oracle.com ([156.151.31.86]:39982 "EHLO
        userp2130.oracle.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1730111AbfBEW7e (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 5 Feb 2019 17:59:34 -0500
Received: from pps.filterd (userp2130.oracle.com [127.0.0.1])
        by userp2130.oracle.com (8.16.0.27/8.16.0.27) with SMTP id
 x15MxFVA067656;
        Tue, 5 Feb 2019 22:59:26 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com;
 h=from : to : cc :
 subject : date : message-id : in-reply-to : references; s=corp-2018-07-02;
 bh=EGymzsgAvMkdBzbQ7FuHCvcqtAqGBuOf/5D0zactunQ=;
 b=S4oBam8rEMZFhaEFOMUtMCaCEKoYuBp0hEi/iX75DmzrR0bkUoBhJ0TS6HuMY5LptW8L
 oM58B56cnGVnwG66B11RJKvuxRvPXMn3Q3NUNVI6FiFbAVOPBtVqYQdhk1HWndePnZhr
 LQsoSOCasPAActuq1+IeWrUyBi5Uns6UqHYYCrItHN1VltR/5ITUcLvh86m8K2c15Oa7
 2+mtmaUk6Ec5XaMvYqco+HCWcsfipVNdywMf9lrOYVly1sN/YWIJ8u7ZbexKsX0KJB9l
 lE070/BZPiYqpFp+QH0ryvYG5zjpT1/S5yOypODBTKNcp0rZaQmYyKitMZLHIS7K9nVw Kg==
Received: from userv0021.oracle.com (userv0021.oracle.com [156.151.31.71])
        by userp2130.oracle.com with ESMTP id 2qd9are16d-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 05 Feb 2019 22:59:26 +0000
Received: from aserv0121.oracle.com (aserv0121.oracle.com [141.146.126.235])
        by userv0021.oracle.com (8.14.4/8.14.4) with ESMTP id x15MxPSf026882
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 5 Feb 2019 22:59:25 GMT
Received: from abhmp0004.oracle.com (abhmp0004.oracle.com [141.146.116.10])
        by aserv0121.oracle.com (8.14.4/8.13.8) with ESMTP id x15MxPIU016505;
        Tue, 5 Feb 2019 22:59:25 GMT
Received: from ban25x6uut29.us.oracle.com (/10.153.73.29)
        by default (Oracle Beehive Gateway v4.0)
        with ESMTP ; Tue, 05 Feb 2019 22:59:25 +0000
From: Krish Sadhukhan <krish.sadhukhan@oracle.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, jmattson@google.com
Subject: [PATCH 3/4 v2][kvm-unit-test nVMX]: Change 'test_vmx_controls' to
 'test_vmlaunch' and add a parameter for expected error
Date: Tue,  5 Feb 2019 17:34:26 -0500
Message-Id: <20190205223427.7387-4-krish.sadhukhan@oracle.com>
X-Mailer: git-send-email 2.17.2
In-Reply-To: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
References: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
X-Proofpoint-Virus-Version: vendor=nai engine=5900 definitions=9158
 signatures=668682
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0
 priorityscore=1501 malwarescore=0
 suspectscore=1 phishscore=0 bulkscore=0 spamscore=0 clxscore=1015
 lowpriorityscore=0 mlxscore=0 impostorscore=0 mlxlogscore=967 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.0.1-1810050000
 definitions=main-1902050168
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

The function 'test_vmx_controls' has thus far been used to test the VMX
controls and has the expected error code (returned by KVM) hard-coded in it.
When vmlaunch fails due to a bad Host State Area, the error code returned by
KVM is different. So rename this function and add a new parameter so that it
can also be used for testing the Host State Area during vmlaunch of L2 guests.

Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
---
 x86/vmx_tests.c | 164 +++++++++++++++++++++++++-----------------------
 1 file changed, 86 insertions(+), 78 deletions(-)

diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index 9a3cdee..b69a7d9 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -3285,7 +3285,7 @@ success:
 /*
  * Try to launch the current VMCS.
  */
-static void test_vmx_controls(bool controls_valid, bool xfail)
+static void test_vmlaunch(bool controls_valid, bool xfail, u32 error_expected)
 {
 	bool success = vmlaunch_succeeds();
 	u32 vmx_inst_err;
@@ -3295,8 +3295,8 @@ static void test_vmx_controls(bool controls_valid, bool xfail)
 	if (!success) {
 		vmx_inst_err = vmcs_read(VMX_INST_ERROR);
 		report("VMX inst error is %d (actual %d)",
-		       vmx_inst_err == VMXERR_ENTRY_INVALID_CONTROL_FIELD,
-		       VMXERR_ENTRY_INVALID_CONTROL_FIELD, vmx_inst_err);
+		       vmx_inst_err == error_expected, error_expected,
+		       vmx_inst_err);
 	}
 }
 
@@ -3334,7 +3334,7 @@ static void test_rsvd_ctl_bit_value(const char *name, union vmx_ctrl_msr msr,
 		vmcs_write(encoding, msr.set & ~mask);
 		expected = !(msr.set & mask);
 	}
-	test_vmx_controls(expected, false);
+	test_vmlaunch(expected, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	vmcs_write(encoding, controls);
 	report_prefix_pop();
 }
@@ -3430,7 +3430,7 @@ static void try_cr3_target_count(unsigned i, unsigned max)
 {
 	report_prefix_pushf("CR3 target count 0x%x", i);
 	vmcs_write(CR3_TARGET_COUNT, i);
-	test_vmx_controls(i <= max, false);
+	test_vmlaunch(i <= max, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 }
 
@@ -3475,9 +3475,9 @@ static void test_vmcs_addr(const char *name,
 
 	report_prefix_pushf("%s = %lx", name, addr);
 	vmcs_write(encoding, addr);
-	test_vmx_controls(ignored || (IS_ALIGNED(addr, align) &&
+	test_vmlaunch(ignored || (IS_ALIGNED(addr, align) &&
 				  addr < (1ul << cpuid_maxphyaddr())),
-			  xfail);
+			  xfail, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 	xfail = false;
 }
@@ -3696,7 +3696,8 @@ static void test_apic_virtual_ctls(void)
 			vmcs_write(CPU_EXEC_CTRL1, secondary);
 			report_prefix_pushf("Use TPR shadow %s, virtualize x2APIC mode %s, APIC-register virtualization %s, virtual-interrupt delivery %s",
 				str, (secondary & CPU_VIRT_X2APIC) ? "enabled" : "disabled", (secondary & CPU_APIC_REG_VIRT) ? "enabled" : "disabled", (secondary & CPU_VINTD) ? "enabled" : "disabled");
-			test_vmx_controls(ctrl, false);
+			test_vmlaunch(ctrl, false,
+					VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 			report_prefix_pop();
 		}
 
@@ -3723,22 +3724,22 @@ static void test_apic_virtual_ctls(void)
 	secondary &= ~CPU_VIRT_APIC_ACCESSES;
 	vmcs_write(CPU_EXEC_CTRL1, secondary & ~CPU_VIRT_X2APIC);
 	report_prefix_pushf("Virtualize x2APIC mode disabled; virtualize APIC access disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL1, secondary | CPU_VIRT_APIC_ACCESSES);
 	report_prefix_pushf("Virtualize x2APIC mode disabled; virtualize APIC access enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL1, secondary | CPU_VIRT_X2APIC);
 	report_prefix_pushf("Virtualize x2APIC mode enabled; virtualize APIC access enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL1, secondary & ~CPU_VIRT_APIC_ACCESSES);
 	report_prefix_pushf("Virtualize x2APIC mode enabled; virtualize APIC access disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL0, saved_primary);
@@ -3767,22 +3768,22 @@ static void test_virtual_intr_ctls(void)
 	vmcs_write(CPU_EXEC_CTRL1, secondary & ~CPU_VINTD);
 	vmcs_write(PIN_CONTROLS, pin & ~PIN_EXTINT);
 	report_prefix_pushf("Virtualize interrupt-delivery disabled; external-interrupt exiting disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL1, secondary | CPU_VINTD);
 	report_prefix_pushf("Virtualize interrupt-delivery enabled; external-interrupt exiting disabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, pin | PIN_EXTINT);
 	report_prefix_pushf("Virtualize interrupt-delivery enabled; external-interrupt exiting enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, pin & ~PIN_EXTINT);
 	report_prefix_pushf("Virtualize interrupt-delivery enabled; external-interrupt exiting disabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL0, saved_primary);
@@ -3794,7 +3795,7 @@ static void test_pi_desc_addr(u64 addr, bool ctrl)
 {
 	vmcs_write(POSTED_INTR_DESC_ADDR, addr);
 	report_prefix_pushf("Process-posted-interrupts enabled; posted-interrupt-descriptor-address 0x%lx", addr);
-	test_vmx_controls(ctrl, false);
+	test_vmlaunch(ctrl, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 }
 
@@ -3839,37 +3840,37 @@ static void test_posted_intr(void)
 	secondary &= ~CPU_VINTD;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Process-posted-interrupts enabled; virtual-interrupt-delivery disabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary |= CPU_VINTD;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Process-posted-interrupts enabled; virtual-interrupt-delivery enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	exit_ctl &= ~EXI_INTA;
 	vmcs_write(EXI_CONTROLS, exit_ctl);
 	report_prefix_pushf("Process-posted-interrupts enabled; virtual-interrupt-delivery enabled; acknowledge-interrupt-on-exit disabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	exit_ctl |= EXI_INTA;
 	vmcs_write(EXI_CONTROLS, exit_ctl);
 	report_prefix_pushf("Process-posted-interrupts enabled; virtual-interrupt-delivery enabled; acknowledge-interrupt-on-exit enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary &= ~CPU_VINTD;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Process-posted-interrupts enabled; virtual-interrupt-delivery disabled; acknowledge-interrupt-on-exit enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary |= CPU_VINTD;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Process-posted-interrupts enabled; virtual-interrupt-delivery enabled; acknowledge-interrupt-on-exit enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/*
@@ -3879,21 +3880,21 @@ static void test_posted_intr(void)
 		vec = (1ul << i);
 		vmcs_write(PINV, vec);
 		report_prefix_pushf("Process-posted-interrupts enabled; posted-interrupt-notification-vector %u", vec);
-		test_vmx_controls(true, false);
+		test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 	for (i = 8; i < 16; i++) {
 		vec = (1ul << i);
 		vmcs_write(PINV, vec);
 		report_prefix_pushf("Process-posted-interrupts enabled; posted-interrupt-notification-vector %u", vec);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
 	vec &= ~(0xff << 8);
 	vmcs_write(PINV, vec);
 	report_prefix_pushf("Process-posted-interrupts enabled; posted-interrupt-notification-vector %u", vec);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/*
@@ -3950,19 +3951,19 @@ static void test_vpid(void)
 	vmcs_write(CPU_EXEC_CTRL1, saved_secondary & ~CPU_VPID);
 	vmcs_write(VPID, vpid);
 	report_prefix_pushf("VPID disabled; VPID value %x", vpid);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL1, saved_secondary | CPU_VPID);
 	report_prefix_pushf("VPID enabled; VPID value %x", vpid);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	for (i = 0; i < 16; i++) {
 		vpid = (short)1 << i;;
 		vmcs_write(VPID, vpid);
 		report_prefix_pushf("VPID enabled; VPID value %x", vpid);
-		test_vmx_controls(true, false);
+		test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
@@ -3989,7 +3990,7 @@ static void try_tpr_threshold_and_vtpr(unsigned threshold, unsigned vtpr)
 	set_vtpr(vtpr);
 	report_prefix_pushf("TPR threshold 0x%x, VTPR.class 0x%x",
 	    threshold, (vtpr >> 4) & 0xf);
-	test_vmx_controls(valid, false);
+	test_vmlaunch(valid, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 }
 
@@ -4016,7 +4017,7 @@ static void test_invalid_event_injection(void)
 			    "RESERVED interruption type invalid [-]",
 			    ent_intr_info);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	ent_intr_info = ent_intr_info_base | INTR_TYPE_EXT_INTR |
@@ -4025,7 +4026,7 @@ static void test_invalid_event_injection(void)
 			    "RESERVED interruption type invalid [+]",
 			    ent_intr_info);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/* If the interruption type is other event, the vector is 0. */
@@ -4034,7 +4035,7 @@ static void test_invalid_event_injection(void)
 			    "(OTHER EVENT && vector != 0) invalid [-]",
 			    ent_intr_info);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/* If the interruption type is NMI, the vector is 2 (negative case). */
@@ -4042,7 +4043,7 @@ static void test_invalid_event_injection(void)
 	report_prefix_pushf("%s, VM-entry intr info=0x%x",
 			    "(NMI && vector != 2) invalid [-]", ent_intr_info);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/* If the interruption type is NMI, the vector is 2 (positive case). */
@@ -4050,7 +4051,7 @@ static void test_invalid_event_injection(void)
 	report_prefix_pushf("%s, VM-entry intr info=0x%x",
 			    "(NMI && vector == 2) valid [+]", ent_intr_info);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/*
@@ -4062,7 +4063,7 @@ static void test_invalid_event_injection(void)
 			    "(HW exception && vector > 31) invalid [-]",
 			    ent_intr_info);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/*
@@ -4078,7 +4079,7 @@ static void test_invalid_event_injection(void)
 	disable_unrestricted_guest();
 	vmcs_write(GUEST_CR0, guest_cr0_save & ~X86_CR0_PE & ~X86_CR0_PG);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	ent_intr_info = ent_intr_info_base | INTR_INFO_DELIVER_CODE_MASK |
@@ -4089,7 +4090,7 @@ static void test_invalid_event_injection(void)
 	disable_unrestricted_guest();
 	vmcs_write(GUEST_CR0, guest_cr0_save & ~X86_CR0_PE & ~X86_CR0_PG);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	ent_intr_info = ent_intr_info_base | INTR_INFO_DELIVER_CODE_MASK |
@@ -4100,7 +4101,7 @@ static void test_invalid_event_injection(void)
 	enable_unrestricted_guest();
 	vmcs_write(GUEST_CR0, guest_cr0_save & ~X86_CR0_PE & ~X86_CR0_PG);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	ent_intr_info = ent_intr_info_base | INTR_TYPE_HARD_EXCEPTION |
@@ -4110,7 +4111,7 @@ static void test_invalid_event_injection(void)
 			    ent_intr_info);
 	vmcs_write(GUEST_CR0, guest_cr0_save | X86_CR0_PE);
 	vmcs_write(ENT_INTR_INFO, ent_intr_info);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/* deliver-error-code is 1 iff the interruption type is HW exception */
@@ -4126,7 +4127,7 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr info=0x%x [-]",
 				    ent_intr_info);
 		vmcs_write(ENT_INTR_INFO, ent_intr_info);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 	report_prefix_pop();
@@ -4160,7 +4161,8 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr info=0x%x [-]",
 				    ent_intr_info);
 		vmcs_write(ENT_INTR_INFO, ent_intr_info);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 
 		/* Positive case */
@@ -4172,7 +4174,7 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr info=0x%x [+]",
 				    ent_intr_info);
 		vmcs_write(ENT_INTR_INFO, ent_intr_info);
-		test_vmx_controls(true, false);
+		test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 	report_prefix_pop();
@@ -4187,7 +4189,8 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr info=0x%x [-]",
 				    ent_intr_info);
 		vmcs_write(ENT_INTR_INFO, ent_intr_info);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 	report_prefix_pop();
@@ -4207,7 +4210,8 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr error=0x%x [-]",
 				    ent_intr_err);
 		vmcs_write(ENT_INTR_ERROR, ent_intr_err);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 	vmcs_write(ENT_INTR_ERROR, 0x00000000);
@@ -4244,7 +4248,8 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr length = 0x%x [-]",
 				    ent_intr_len);
 		vmcs_write(ENT_INST_LEN, ent_intr_len);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 
 		/* Instruction length set to 16 should fail */
@@ -4252,7 +4257,8 @@ static void test_invalid_event_injection(void)
 		report_prefix_pushf("VM-entry intr length = 0x%x [-]",
 				    ent_intr_len);
 		vmcs_write(ENT_INST_LEN, 0x00000010);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 
 		report_prefix_pop();
@@ -4292,7 +4298,7 @@ static void try_tpr_threshold(unsigned threshold)
 	set_vtpr(-1);
 	vmcs_write(TPR_THRESHOLD, threshold);
 	report_prefix_pushf("TPR threshold 0x%x, VTPR.class 0xf", threshold);
-	test_vmx_controls(valid, false);
+	test_vmlaunch(valid, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	if (valid)
@@ -4440,22 +4446,22 @@ static void test_nmi_ctrls(void)
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls);
 	report_prefix_pushf("NMI-exiting disabled, virtual-NMIs disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls | PIN_VIRT_NMI);
 	report_prefix_pushf("NMI-exiting disabled, virtual-NMIs enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls | (PIN_NMI | PIN_VIRT_NMI));
 	report_prefix_pushf("NMI-exiting enabled, virtual-NMIs enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls | PIN_NMI);
 	report_prefix_pushf("NMI-exiting enabled, virtual-NMIs disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	if (!(ctrl_cpu_rev[0].clr & CPU_NMI_WINDOW)) {
@@ -4466,25 +4472,25 @@ static void test_nmi_ctrls(void)
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls);
 	vmcs_write(CPU_EXEC_CTRL0, test_cpu_ctrls0 | CPU_NMI_WINDOW);
 	report_prefix_pushf("Virtual-NMIs disabled, NMI-window-exiting enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls);
 	vmcs_write(CPU_EXEC_CTRL0, test_cpu_ctrls0);
 	report_prefix_pushf("Virtual-NMIs disabled, NMI-window-exiting disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls | (PIN_NMI | PIN_VIRT_NMI));
 	vmcs_write(CPU_EXEC_CTRL0, test_cpu_ctrls0 | CPU_NMI_WINDOW);
 	report_prefix_pushf("Virtual-NMIs enabled, NMI-window-exiting enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, test_pin_ctrls | (PIN_NMI | PIN_VIRT_NMI));
 	vmcs_write(CPU_EXEC_CTRL0, test_cpu_ctrls0);
 	report_prefix_pushf("Virtual-NMIs enabled, NMI-window-exiting disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	/* Restore the controls to their original values */
@@ -4498,7 +4504,7 @@ static void test_eptp_ad_bit(u64 eptp, bool ctrl)
 	vmcs_write(EPTP, eptp);
 	report_prefix_pushf("Enable-EPT enabled; EPT accessed and dirty flag %s",
 	    (eptp & EPTP_AD_FLAG) ? "1": "0");
-	test_vmx_controls(ctrl, false);
+	test_vmlaunch(ctrl, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 }
@@ -4581,7 +4587,7 @@ static void test_ept_eptp(void)
 		vmcs_write(EPTP, eptp);
 		report_prefix_pushf("Enable-EPT enabled; EPT memory type %lu",
 		    eptp & EPT_MEM_TYPE_MASK);
-		test_vmx_controls(ctrl, false);
+		test_vmlaunch(ctrl, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
@@ -4601,7 +4607,7 @@ static void test_ept_eptp(void)
 		vmcs_write(EPTP, eptp);
 		report_prefix_pushf("Enable-EPT enabled; EPT page walk length %lu",
 		    eptp & EPTP_PG_WALK_LEN_MASK);
-		test_vmx_controls(ctrl, false);
+		test_vmlaunch(ctrl, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
@@ -4643,7 +4649,7 @@ static void test_ept_eptp(void)
 		report_prefix_pushf("Enable-EPT enabled; reserved bits [11:7] %lu",
 		    (eptp >> EPTP_RESERV_BITS_SHIFT) &
 		    EPTP_RESERV_BITS_MASK);
-		test_vmx_controls(ctrl, false);
+		test_vmlaunch(ctrl, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
@@ -4665,32 +4671,32 @@ static void test_ept_eptp(void)
 		vmcs_write(EPTP, eptp);
 		report_prefix_pushf("Enable-EPT enabled; reserved bits [63:N] %lu",
 		    (eptp >> maxphysaddr) & resv_bits_mask);
-		test_vmx_controls(ctrl, false);
+		test_vmlaunch(ctrl, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
 	secondary &= ~(CPU_EPT | CPU_URG);
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Enable-EPT disabled, unrestricted-guest disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary |= CPU_URG;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Enable-EPT disabled, unrestricted-guest enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary |= CPU_EPT;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Enable-EPT enabled, unrestricted-guest enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary &= ~CPU_URG;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("Enable-EPT enabled, unrestricted-guest disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(CPU_EXEC_CTRL0, primary_saved);
@@ -4727,25 +4733,25 @@ static void test_pml(void)
 	secondary &= ~(CPU_PML | CPU_EPT);
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("enable-PML disabled, enable-EPT disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary |= CPU_PML;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("enable-PML enabled, enable-EPT disabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary |= CPU_EPT;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("enable-PML enabled, enable-EPT enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	secondary &= ~CPU_PML;
 	vmcs_write(CPU_EXEC_CTRL1, secondary);
 	report_prefix_pushf("enable-PML disabled, enable EPT enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	test_vmcs_addr_reference(CPU_PML, PMLADDR, "PML address", "PML",
@@ -4779,25 +4785,25 @@ static void test_vmx_preemption_timer(void)
 	exit &= ~EXI_SAVE_PREEMPT;
 	vmcs_write(EXI_CONTROLS, exit);
 	report_prefix_pushf("enable-VMX-preemption-timer enabled, save-VMX-preemption-timer disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	exit |= EXI_SAVE_PREEMPT;
 	vmcs_write(EXI_CONTROLS, exit);
 	report_prefix_pushf("enable-VMX-preemption-timer enabled, save-VMX-preemption-timer enabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	pin &= ~PIN_PREEMPT;
 	vmcs_write(PIN_CONTROLS, pin);
 	report_prefix_pushf("enable-VMX-preemption-timer disabled, save-VMX-preemption-timer enabled");
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	exit &= ~EXI_SAVE_PREEMPT;
 	vmcs_write(EXI_CONTROLS, exit);
 	report_prefix_pushf("enable-VMX-preemption-timer disabled, save-VMX-preemption-timer disabled");
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	report_prefix_pop();
 
 	vmcs_write(PIN_CONTROLS, saved_pin);
@@ -4867,7 +4873,8 @@ static void test_exit_msr_store(void)
 		vmcs_write(EXIT_MSR_ST_ADDR, tmp);
 		report_prefix_pushf("VM-exit MSR-store addr [4:0] %lx",
 				    tmp & 0xf);
-		test_vmx_controls(false, false);
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 		report_prefix_pop();
 	}
 
@@ -4889,16 +4896,17 @@ static void test_exit_msr_store(void)
 			1ul << i;
 		vmcs_write(EXIT_MSR_ST_ADDR,
 			   tmp - (exit_msr_st_cnt * 16 - 1));
-                test_vmx_controls(false, false);
+                test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	}
 
 	vmcs_write(EXI_MSR_ST_CNT, 2);
 	vmcs_write(EXIT_MSR_ST_ADDR, (1ULL << cpuid_maxphyaddr()) - 16);
-	test_vmx_controls(false, false);
+	test_vmlaunch(false, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	vmcs_write(EXIT_MSR_ST_ADDR, (1ULL << cpuid_maxphyaddr()) - 32);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 	vmcs_write(EXIT_MSR_ST_ADDR, (1ULL << cpuid_maxphyaddr()) - 48);
-	test_vmx_controls(true, false);
+	test_vmlaunch(true, false, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 }
 
 /*

From patchwork Tue Feb  5 22:34:27 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Krish Sadhukhan <krish.sadhukhan@oracle.com>
X-Patchwork-Id: 10798645
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id E9E4E13B4
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DB4602C54B
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id CFC262C5AD; Tue,  5 Feb 2019 22:59:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI,
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BF5922C54B
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue,  5 Feb 2019 22:59:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1730384AbfBEW7e (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 5 Feb 2019 17:59:34 -0500
Received: from userp2130.oracle.com ([156.151.31.86]:39972 "EHLO
        userp2130.oracle.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1729312AbfBEW7d (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 5 Feb 2019 17:59:33 -0500
Received: from pps.filterd (userp2130.oracle.com [127.0.0.1])
        by userp2130.oracle.com (8.16.0.27/8.16.0.27) with SMTP id
 x15MxR2D067939;
        Tue, 5 Feb 2019 22:59:27 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com;
 h=from : to : cc :
 subject : date : message-id : in-reply-to : references; s=corp-2018-07-02;
 bh=fuOnEijO9SbXMMrAMB24KyZW8299Kc8hJyYut3NCC6s=;
 b=pBwuN0g69kmlvM1qFOjkHHfuAjKziRKjYiu5kximdvF4Puy8i4XwtzJ07BHYrlbUpgmV
 puPp8B1vDYRmJWDNj0wjedEKq40PZHlZC38Gp05RchGg0E65EvNz1tBdOrvFWmZ7WCRX
 lgXXjj83m7+TyDSw2b7Arc89w9HwXvsqLhGU4Aos7DYiDhn1hDVzoQ3tp9WYB+LFpU+7
 tyqX6cVYDbK4jM17YtDto2SWuJdiXSs6Ltc/y93MVIZc19UeAiI9FNPTJQBDVHnXCwx/
 N5GmvrQdDM0gtGb5iV5CBQTfQzHUf/DDu54dPADOWKd2t9mhzg/qh2RxtWhmSqQCZRAl 5g==
Received: from aserv0021.oracle.com (aserv0021.oracle.com [141.146.126.233])
        by userp2130.oracle.com with ESMTP id 2qd9are16h-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 05 Feb 2019 22:59:27 +0000
Received: from userv0121.oracle.com (userv0121.oracle.com [156.151.31.72])
        by aserv0021.oracle.com (8.14.4/8.14.4) with ESMTP id x15MxQLE002379
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 5 Feb 2019 22:59:26 GMT
Received: from abhmp0004.oracle.com (abhmp0004.oracle.com [141.146.116.10])
        by userv0121.oracle.com (8.14.4/8.13.8) with ESMTP id x15MxPpg004162;
        Tue, 5 Feb 2019 22:59:25 GMT
Received: from ban25x6uut29.us.oracle.com (/10.153.73.29)
        by default (Oracle Beehive Gateway v4.0)
        with ESMTP ; Tue, 05 Feb 2019 22:59:25 +0000
From: Krish Sadhukhan <krish.sadhukhan@oracle.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, jmattson@google.com
Subject: [PATCH 4/4 v2][kvm-unit-test nVMX]: Test HOST_SYSENTER_ESP and
 HOST_SYSENTER_EIP fields on vmentry of L2 guests
Date: Tue,  5 Feb 2019 17:34:27 -0500
Message-Id: <20190205223427.7387-5-krish.sadhukhan@oracle.com>
X-Mailer: git-send-email 2.17.2
In-Reply-To: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
References: <20190205223427.7387-1-krish.sadhukhan@oracle.com>
X-Proofpoint-Virus-Version: vendor=nai engine=5900 definitions=9158
 signatures=668682
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0
 priorityscore=1501 malwarescore=0
 suspectscore=1 phishscore=0 bulkscore=0 spamscore=0 clxscore=1015
 lowpriorityscore=0 mlxscore=0 impostorscore=0 mlxlogscore=884 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.0.1-1810050000
 definitions=main-1902050168
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

According to section "Checks on VMX Controls" in Intel SDM vol 3C, the
following check is performed on vmentry of L2 guests:

    On processors that support Intel 64 architecture, the IA32_SYSENTER_ESP
    field and the IA32_SYSENTER_EIP field must each contain a canonical
    address.

Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
Reviewed-by: Mihai Carabas <mihai.carabas@oracle.com>
---
 x86/unittests.cfg |  6 ++++
 x86/vmx_tests.c   | 75 +++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 81 insertions(+)

diff --git a/x86/unittests.cfg b/x86/unittests.cfg
index d7975e9..580dd8c 100644
--- a/x86/unittests.cfg
+++ b/x86/unittests.cfg
@@ -542,6 +542,12 @@ extra_params = -cpu host,+vmx -m 2560 -append vmx_controls_test
 arch = x86_64
 groups = vmx
 
+[vmx_host_state_area]
+file = vmx.flat
+extra_params = -cpu host,+vmx -m 2560 -append vmx_host_state_area_test
+arch = x86_64
+groups = vmx
+
 [vmx_vmentry_movss_shadow_test]
 file = vmx.flat
 extra_params = -cpu host,+vmx -m 2560 -append vmentry_movss_shadow_test
diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index b69a7d9..487eb6f 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -4935,6 +4935,80 @@ static void vmx_controls_test(void)
 	test_vm_entry_ctls();
 }
 
+/*
+ * On processors that support Intel 64 architecture, the IA32_SYSENTER_ESP
+ * field and the IA32_SYSENTER_EIP field must each contain a canonical
+ * address.
+ *
+ *  [Intel SDM]
+ */
+static void test_host_ctl_regs(void)
+{
+	u64 addr_saved = vmcs_read(HOST_SYSENTER_ESP);
+	u64 addr = addr_saved;
+
+	if (!is_canonical(addr)) {
+		report_prefix_pushf("HOST_SYSENTER_ESP non-canonical");
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
+		report_prefix_pop();
+	} else {
+		report_prefix_pushf("HOST_SYSENTER_ESP canonical");
+		test_vmlaunch(true, false,
+				VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
+		report_prefix_pop();
+
+		addr |= 1ull << 48;
+		vmcs_write(HOST_SYSENTER_ESP, addr);
+		report_prefix_pushf("HOST_SYSENTER_ESP non-canonical");
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
+		report_prefix_pop();
+
+		vmcs_write(HOST_SYSENTER_ESP, addr_saved);
+	}
+
+	addr_saved = vmcs_read(HOST_SYSENTER_EIP);
+	addr = addr_saved;
+
+	if (!is_canonical(addr)) {
+		report_prefix_pushf("HOST_SYSENTER_EIP non-canonical");
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
+		report_prefix_pop();
+	} else {
+		report_prefix_pushf("HOST_SYSENTER_EIP canonical");
+		test_vmlaunch(true, false,
+				VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
+		report_prefix_pop();
+
+		addr |= 1ull << 48;
+		vmcs_write(HOST_SYSENTER_EIP, addr);
+		report_prefix_pushf("HOST_SYSENTER_EIP non-canonical");
+		test_vmlaunch(false, false,
+				VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
+		report_prefix_pop();
+
+		vmcs_write(HOST_SYSENTER_EIP, addr_saved);
+	}
+}
+
+/*
+ * Check that the virtual CPU checks the VMX Host State Area as
+ * documented in the Intel SDM.
+ */
+static void vmx_host_state_area_test(void)
+{
+	/*
+	 * Bit 1 of the guest's RFLAGS must be 1, or VM-entry will
+	 * fail due to invalid guest state, should we make it that
+	 * far.
+	 */
+	vmcs_write(GUEST_RFLAGS, 0);
+
+	test_host_ctl_regs();
+}
+
 static bool valid_vmcs_for_vmentry(void)
 {
 	struct vmcs *current_vmcs = NULL;
@@ -6356,6 +6430,7 @@ struct vmx_test vmx_tests[] = {
 	TEST(invvpid_test_v2),
 	/* VM-entry tests */
 	TEST(vmx_controls_test),
+	TEST(vmx_host_state_area_test),
 	TEST(vmentry_movss_shadow_test),
 	/* APICv tests */
 	TEST(vmx_eoi_bitmap_ioapic_scan_test),
