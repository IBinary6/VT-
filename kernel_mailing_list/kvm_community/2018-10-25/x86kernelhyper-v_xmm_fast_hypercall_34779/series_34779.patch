From patchwork Thu Oct 25 04:48:26 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Isaku Yamahata <isaku.yamahata@gmail.com>
X-Patchwork-Id: 10655405
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 1B71D109C
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:46 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 088D62B021
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:46 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id F0BD42B0A6; Thu, 25 Oct 2018 04:48:45 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1E0012B021
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727199AbeJYNTn (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Thu, 25 Oct 2018 09:19:43 -0400
Received: from mail-pl1-f193.google.com ([209.85.214.193]:35091 "EHLO
        mail-pl1-f193.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726527AbeJYNTn (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 25 Oct 2018 09:19:43 -0400
Received: by mail-pl1-f193.google.com with SMTP id f8-v6so3280726plb.2
        for <kvm@vger.kernel.org>; Wed, 24 Oct 2018 21:48:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :in-reply-to:references;
        bh=lE9OF2J/os2FxsJq5nHSmfvePN6RJHuiOhJKoWIStoE=;
        b=M6TDJXFC/CYhAnpsfUpJioKoKSyEFM3pSL/zRi2AyYNl5Nw3gIrOvkWqEjqVWhaNAY
         hEcvZ0z9MTJeVeuTHNQeWkC9aaoZ2GrGe7tO33LCahybdHJBDS48D73+FeNN11vGb3sN
         f+J5ufyQ/e8DqElaCiShUKrjP9nlFRPVcov6a3DQxl7yoX0wxO7yHWLkNykrmUFzV8Hf
         U1/HYuIgqFWj8VhLYDkTuxSRMWwf14Q6KoOtAC+Yxgn4O1tkqQ1Kx/p36MEbnEPNdQN8
         AWnHpwzUP6IO+R1I57xZH09MQr63gNrXdY3GEqAJq7Il0mQQNH0++uYjgAzHhQc3VTqf
         M4xA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:in-reply-to:references;
        bh=lE9OF2J/os2FxsJq5nHSmfvePN6RJHuiOhJKoWIStoE=;
        b=R5UXihn/NtvxDuL0X0u7+dbttHHvH1w/fVoi2sVttiw69S0qlqWQIBovgtKwvJsCXS
         j5V32yRfSW2xxxEdWMJaplsIs1r8b+7xbQb+ZcHNO7xIxYwUQPoDnKeN0z5bZKQbaLQI
         qfCQK2g8n6QevGJoA6+7bRHeOecB5w/2EtedA5oq45Sd4Y5ADQvSsonuMtPFHjz+qzML
         NsnE5FXFsp6jzKLJnaHc+opSrZDDNWwY27M1L55/yrrG49VnE/HAfuq2MkCww/VH1fqB
         F8r7bnyfeHZdPL0x9GReIBkOrH9nYacUFdz+udHWRLRvRJv1gfa4iSmlwVYkTS1s8iED
         vAgg==
X-Gm-Message-State: AGRZ1gJsA0dqvgy68lcrsrAWm57yaihd537tPnob7rP6nJ8jDvgKu09M
        znVG+twHq1q0Y1ht/fQn/V52JF7S
X-Google-Smtp-Source: 
 AJdET5dEgreDPN03cSbgMnp12Ygkigym76Ex/i8scdgnQAzFAlX4JuvGzYd1/AhGK2BWkO/vIz+HGQ==
X-Received: by 2002:a17:902:f209:: with SMTP id gn9mr65401plb.6.1540442922539;
        Wed, 24 Oct 2018 21:48:42 -0700 (PDT)
Received: from localhost (c-73-189-176-234.hsd1.ca.comcast.net.
 [73.189.176.234])
        by smtp.gmail.com with ESMTPSA id
 84-v6sm8605083pfv.33.2018.10.24.21.48.41
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Wed, 24 Oct 2018 21:48:41 -0700 (PDT)
From: Isaku Yamahata <isaku.yamahata@gmail.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, vkuznets@redhat.com,
        kys@microsoft.com, Tianyu.Lan@microsoft.com, yi.y.sun@intel.com,
        chao.gao@intel.com, isaku.yamahta@intel.com,
        Isaku Yamahata <isaku.yamahata@gmail.com>
Subject: [PATCH v2 1/6] x86/kernel/hyper-v: xmm fast hypercall as guest
Date: Wed, 24 Oct 2018 21:48:26 -0700
Message-Id: 
 <8118b856cb8d566d04fcb6e5466acf99f983876d.1540441925.git.isaku.yamahata@gmail.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

hyper-v hypercall supports xmm fast hypercall
where argument is exchanged though regular/xmm registers.
This patch implements them and make use of them.
With this patch, hyperv/hv_apic.c and hyperv/mmu.c will use (xmm) fast
hypercall.

Signed-off-by: Isaku Yamahata <isaku.yamahata@gmail.com>
---
 arch/x86/hyperv/mmu.c               |   4 +-
 arch/x86/hyperv/nested.c            |   2 +-
 arch/x86/include/asm/hyperv-tlfs.h  |   3 +
 arch/x86/include/asm/mshyperv.h     | 176 ++++++++++++++++++++++++++++++++++--
 drivers/hv/hv.c                     |   3 +-
 drivers/pci/controller/pci-hyperv.c |   7 +-
 6 files changed, 179 insertions(+), 16 deletions(-)

diff --git a/arch/x86/hyperv/mmu.c b/arch/x86/hyperv/mmu.c
index ef5f29f913d7..41820372bb3d 100644
--- a/arch/x86/hyperv/mmu.c
+++ b/arch/x86/hyperv/mmu.c
@@ -134,11 +134,11 @@ static void hyperv_flush_tlb_others(const struct cpumask *cpus,
 	if (info->end == TLB_FLUSH_ALL) {
 		flush->flags |= HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY;
 		status = hv_do_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE,
-					 flush, NULL);
+					 flush, sizeof(*flush), NULL, 0);
 	} else if (info->end &&
 		   ((info->end - info->start)/HV_TLB_FLUSH_UNIT) > max_gvas) {
 		status = hv_do_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE,
-					 flush, NULL);
+					 flush, sizeof(*flush), NULL, 0);
 	} else {
 		gva_n = fill_gva_list(flush->gva_list, 0,
 				      info->start, info->end);
diff --git a/arch/x86/hyperv/nested.c b/arch/x86/hyperv/nested.c
index b8e60cc50461..5fd24f4f2ae3 100644
--- a/arch/x86/hyperv/nested.c
+++ b/arch/x86/hyperv/nested.c
@@ -43,7 +43,7 @@ int hyperv_flush_guest_mapping(u64 as)
 	flush->flags = 0;
 
 	status = hv_do_hypercall(HVCALL_FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE,
-				 flush, NULL);
+				 flush, sizeof(*flush), NULL, 0);
 	local_irq_restore(flags);
 
 	if (!(status & HV_HYPERCALL_RESULT_MASK))
diff --git a/arch/x86/include/asm/hyperv-tlfs.h b/arch/x86/include/asm/hyperv-tlfs.h
index 00e01d215f74..d80e0151b790 100644
--- a/arch/x86/include/asm/hyperv-tlfs.h
+++ b/arch/x86/include/asm/hyperv-tlfs.h
@@ -123,6 +123,7 @@
  * registers is available
  */
 #define HV_X64_HYPERCALL_PARAMS_XMM_AVAILABLE		(1 << 4)
+#define HV_X64_HYPERCALL_OUTPUT_XMM_AVAILABLE		(1 << 15)
 /* Support for a virtual guest idle state is available */
 #define HV_X64_GUEST_IDLE_STATE_AVAILABLE		(1 << 5)
 /* Guest crash data handler available */
@@ -383,10 +384,12 @@ enum HV_GENERIC_SET_FORMAT {
 #define HV_HYPERCALL_RESULT_MASK	GENMASK_ULL(15, 0)
 #define HV_HYPERCALL_FAST_BIT		BIT(16)
 #define HV_HYPERCALL_VARHEAD_OFFSET	17
+#define HV_HYPERCALL_VARHEAD_MASK	GENMASK_ULL(26, 17)
 #define HV_HYPERCALL_REP_COMP_OFFSET	32
 #define HV_HYPERCALL_REP_COMP_MASK	GENMASK_ULL(43, 32)
 #define HV_HYPERCALL_REP_START_OFFSET	48
 #define HV_HYPERCALL_REP_START_MASK	GENMASK_ULL(59, 48)
+#define HV_XMM_BYTE_MAX			112
 
 /* hypercall status code */
 #define HV_STATUS_SUCCESS			0
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index f37704497d8f..5d8acb00ab94 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -132,16 +132,13 @@ extern struct clocksource *hyperv_cs;
 extern void *hv_hypercall_pg;
 extern void  __percpu  **hyperv_pcpu_input_arg;
 
-static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
+static inline u64 __hv_do_hypercall(u64 control, void *input, void *output)
 {
 	u64 input_address = input ? virt_to_phys(input) : 0;
 	u64 output_address = output ? virt_to_phys(output) : 0;
 	u64 hv_status;
 
 #ifdef CONFIG_X86_64
-	if (!hv_hypercall_pg)
-		return U64_MAX;
-
 	__asm__ __volatile__("mov %4, %%r8\n"
 			     CALL_NOSPEC
 			     : "=a" (hv_status), ASM_CALL_CONSTRAINT,
@@ -155,9 +152,6 @@ static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
 	u32 output_address_hi = upper_32_bits(output_address);
 	u32 output_address_lo = lower_32_bits(output_address);
 
-	if (!hv_hypercall_pg)
-		return U64_MAX;
-
 	__asm__ __volatile__(CALL_NOSPEC
 			     : "=A" (hv_status),
 			       "+c" (input_address_lo), ASM_CALL_CONSTRAINT
@@ -201,7 +195,7 @@ static inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)
 		return hv_status;
 }
 
-/* Fast hypercall with 16 bytes of input */
+/* Fast hypercall with 16 bytes of input and no output */
 static inline u64 hv_do_fast_hypercall16(u16 code, u64 input1, u64 input2)
 {
 	u64 hv_status, control = (u64)code | HV_HYPERCALL_FAST_BIT;
@@ -246,11 +240,14 @@ static inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,
 	u64 status;
 	u16 rep_comp;
 
+	if (unlikely(!hv_hypercall_pg))
+		return U64_MAX;
+
 	control |= (u64)varhead_size << HV_HYPERCALL_VARHEAD_OFFSET;
 	control |= (u64)rep_count << HV_HYPERCALL_REP_COMP_OFFSET;
 
 	do {
-		status = hv_do_hypercall(control, input, output);
+		status = __hv_do_hypercall(control, input, output);
 		if ((status & HV_HYPERCALL_RESULT_MASK) != HV_STATUS_SUCCESS)
 			return status;
 
@@ -267,6 +264,167 @@ static inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,
 	return status;
 }
 
+/* ibytes = fixed header size + var header size + data size in bytes */
+static inline u64 hv_do_xmm_fast_hypercall(
+	u32 varhead_code, void *input, size_t ibytes,
+	void *output, size_t obytes)
+{
+	u64 control = (u64)varhead_code | HV_HYPERCALL_FAST_BIT;
+	u64 hv_status;
+	u64 input1;
+	u64 input2;
+	size_t i_end = roundup(ibytes, 16);
+	size_t o_end = i_end + roundup(obytes, 16);
+	u64 *ixmm = (u64 *)input + 2;
+	u64 tmp[(o_end - 16) / 8] __aligned((16));
+
+	BUG_ON(i_end <= 16);
+	BUG_ON(o_end > HV_XMM_BYTE_MAX);
+	BUG_ON(!IS_ALIGNED((unsigned long)input, 16));
+	BUG_ON(!IS_ALIGNED((unsigned long)output, 16));
+
+	/* it's assumed that there are at least two inputs */
+	input1 = ((u64 *)input)[0];
+	input2 = ((u64 *)input)[1];
+
+	preempt_disable();
+	if (o_end > 2 * 8)
+		__asm__ __volatile__("movdqa %%xmm0, %0" : : "m" (tmp[0]));
+	if (o_end > 4 * 8)
+		__asm__ __volatile__("movdqa %%xmm1, %0" : : "m" (tmp[2]));
+	if (o_end > 6 * 8)
+		__asm__ __volatile__("movdqa %%xmm2, %0" : : "m" (tmp[4]));
+	if (o_end > 8 * 8)
+		__asm__ __volatile__("movdqa %%xmm3, %0" : : "m" (tmp[6]));
+	if (o_end > 10 * 8)
+		__asm__ __volatile__("movdqa %%xmm4, %0" : : "m" (tmp[8]));
+	if (o_end > 12 * 8)
+		__asm__ __volatile__("movdqa %%xmm5, %0" : : "m" (tmp[10]));
+	if (ibytes > 2 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm0" : : "m" (ixmm[0]));
+	if (ibytes > 4 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm1" : : "m" (ixmm[2]));
+	if (ibytes > 6 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm2" : : "m" (ixmm[4]));
+	if (ibytes > 8 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm3" : : "m" (ixmm[6]));
+	if (ibytes > 10 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm4" : : "m" (ixmm[8]));
+	if (ibytes > 12 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm5" : : "m" (ixmm[10]));
+
+#ifdef CONFIG_X86_64
+	__asm__ __volatile__("mov %4, %%r8\n"
+			     CALL_NOSPEC
+			     : "=a" (hv_status), ASM_CALL_CONSTRAINT,
+			       "+c" (control), "+d" (input1)
+			     : "r" (input2),
+			       THUNK_TARGET(hv_hypercall_pg)
+			     : "cc", "memory", "r8", "r9", "r10", "r11");
+#else
+	{
+		u32 input1_hi = upper_32_bits(input1);
+		u32 input1_lo = lower_32_bits(input1);
+		u32 input2_hi = upper_32_bits(input2);
+		u32 input2_lo = lower_32_bits(input2);
+
+		__asm__ __volatile__ (CALL_NOSPEC
+				      : "=A"(hv_status),
+					"+c"(input1_lo), ASM_CALL_CONSTRAINT
+				      :	"A" (control), "b" (input1_hi),
+					"D"(input2_hi), "S"(input2_lo),
+					THUNK_TARGET(hv_hypercall_pg)
+				      : "cc", "memory");
+	}
+#endif
+	if (output) {
+		u64 *oxmm = (u64 *)output;
+		if (i_end <= 2 * 8 && 2 * 8 < o_end) {
+			__asm__ __volatile__(
+				"movdqa %%xmm0, %0" : "=m" (oxmm[0]));
+			oxmm += 2;
+		}
+		if (i_end <= 4 * 8 && 4 * 8 < o_end) {
+			__asm__ __volatile__(
+				"movdqa %%xmm1, %0" : "=m" (oxmm[0]));
+			oxmm += 2;
+		}
+		if (i_end <= 6 * 8 && 6 * 8 < o_end) {
+			__asm__ __volatile__(
+				"movdqa %%xmm2, %0" : "=m" (oxmm[0]));
+			oxmm += 2;
+		}
+		if (i_end <= 8 * 8 && 8 * 8 < o_end) {
+			__asm__ __volatile__(
+				"movdqa %%xmm3, %0" : "=m" (oxmm[0]));
+			oxmm += 2;
+		}
+		if (i_end <= 10 * 8 && 10 * 8 < o_end) {
+			__asm__ __volatile__(
+				"movdqa %%xmm4, %0" : "=m" (oxmm[0]));
+			oxmm += 2;
+		}
+		if (i_end <= 12 * 8 && 12 * 8 < o_end) {
+			__asm__ __volatile__(
+				"movdqa %%xmm5, %0" : "=m" (oxmm[0]));
+			oxmm += 2;
+		}
+	}
+	if (o_end > 2 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm0" : : "m" (tmp[0]));
+	if (o_end > 4 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm1" : : "m" (tmp[2]));
+	if (o_end > 6 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm2" : : "m" (tmp[4]));
+	if (o_end > 8 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm3" : : "m" (tmp[6]));
+	if (o_end > 10 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm4" : : "m" (tmp[8]));
+	if (o_end > 12 * 8)
+		__asm__ __volatile__("movdqa %0, %%xmm5" : : "m" (tmp[10]));
+	preempt_enable();
+
+	return hv_status;
+}
+
+static inline u64 hv_do_hypercall(
+	u32 varhead_code,
+	void *input, size_t ibytes, void *output, size_t obytes)
+{
+	if (unlikely(!hv_hypercall_pg))
+		return U64_MAX;
+
+	/* fast hypercall */
+	if (output == NULL && ibytes <= 16) {
+		u64 *i = (u64*)input;
+
+		WARN_ON((varhead_code & HV_HYPERCALL_VARHEAD_MASK) != 0);
+		if (ibytes <= 8)
+			return hv_do_fast_hypercall8((u16)varhead_code, i[0]);
+
+		return hv_do_fast_hypercall16((u16)varhead_code, i[0], i[1]);
+	}
+
+	/* xmm fast hypercall */
+	if (static_cpu_has(X86_FEATURE_XMM) &&
+	    ms_hyperv.features & HV_X64_HYPERCALL_PARAMS_XMM_AVAILABLE &&
+	    roundup(ibytes, 16) + obytes <= HV_XMM_BYTE_MAX) {
+		if (output) {
+			if (ms_hyperv.features &
+			    HV_X64_HYPERCALL_OUTPUT_XMM_AVAILABLE)
+				return hv_do_xmm_fast_hypercall(
+					varhead_code, input, ibytes,
+					output, obytes);
+		} else {
+			WARN_ON(obytes > 0);
+			return hv_do_xmm_fast_hypercall(
+				varhead_code, input, ibytes, NULL, 0);
+		}
+	}
+
+	return __hv_do_hypercall((u64)varhead_code, input, output);
+}
+
 /*
  * Hypervisor's notion of virtual processor ID is different from
  * Linux' notion of CPU ID. This information can only be retrieved
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index 748a1c4172a6..b80293861c54 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -92,7 +92,8 @@ int hv_post_message(union hv_connection_id connection_id,
 	aligned_msg->payload_size = payload_size;
 	memcpy((void *)aligned_msg->payload, payload, payload_size);
 
-	status = hv_do_hypercall(HVCALL_POST_MESSAGE, aligned_msg, NULL);
+	/* fast hypercall doesn't seem supported */
+	status = __hv_do_hypercall(HVCALL_POST_MESSAGE, aligned_msg, NULL);
 
 	/* Preemption must remain disabled until after the hypercall
 	 * so some other thread can't get scheduled onto this cpu and
diff --git a/drivers/pci/controller/pci-hyperv.c b/drivers/pci/controller/pci-hyperv.c
index ee80e79db21a..ea4aab9a6d1c 100644
--- a/drivers/pci/controller/pci-hyperv.c
+++ b/drivers/pci/controller/pci-hyperv.c
@@ -461,7 +461,7 @@ struct hv_pcibus_device {
 	struct irq_domain *irq_domain;
 
 	/* hypercall arg, must not cross page boundary */
-	struct retarget_msi_interrupt retarget_msi_interrupt_params;
+	__attribute__((__aligned__(16))) struct retarget_msi_interrupt retarget_msi_interrupt_params;
 
 	spinlock_t retarget_msi_interrupt_lock;
 
@@ -984,8 +984,9 @@ static void hv_irq_unmask(struct irq_data *data)
 		}
 	}
 
-	res = hv_do_hypercall(HVCALL_RETARGET_INTERRUPT | (var_size << 17),
-			      params, NULL);
+	res = hv_do_hypercall(
+		HVCALL_RETARGET_INTERRUPT | (var_size << 17),
+		params, sizeof(*params) + var_size * 8, NULL, 0);
 
 exit_unlock:
 	spin_unlock_irqrestore(&hbus->retarget_msi_interrupt_lock, flags);

From patchwork Thu Oct 25 04:48:27 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Isaku Yamahata <isaku.yamahata@gmail.com>
X-Patchwork-Id: 10655407
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 144A1109C
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:48 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 023BB2B021
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:48 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E9F962B0A6; Thu, 25 Oct 2018 04:48:47 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9C80A2B021
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727236AbeJYNTq (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Thu, 25 Oct 2018 09:19:46 -0400
Received: from mail-pg1-f194.google.com ([209.85.215.194]:40056 "EHLO
        mail-pg1-f194.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727201AbeJYNTq (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 25 Oct 2018 09:19:46 -0400
Received: by mail-pg1-f194.google.com with SMTP id o14-v6so3411186pgv.7
        for <kvm@vger.kernel.org>; Wed, 24 Oct 2018 21:48:45 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :in-reply-to:references;
        bh=XPRzofz2UW/9vU0mdXC5QULoF17XY5dxtcootxY4zUI=;
        b=ouPzdK3Dz/xoo1cRJ3i47+u/xH2DW/GI7hkf/0Kq+oM/ivyG0Y6RALIF5NojNZWKNe
         Zmdoo7zuwcSNhShCLcAdeU57J5IWwxoyC933zayiWEPIL/hghjIuRN7OXBIy8zDvqLFB
         GSKkj7hd7x2g2dGjYFJA55Vrfb9lLbAGWpfwrxSrpiPHhRELq5KOAqpE8Ck0/3N44ADA
         G8NLV+Kevu5tV75z1SC3m4jeX8qlQMUDVNnxbqMGZNtRt5EskTYbAg0n0zZAR2qx/JaZ
         59FsCKb2hv+4z3sowRG1hoog0XHEcDV9LD9iTvCrVw5oKRWkIa2Lv5TTi0dyRSizoHZx
         7SxA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:in-reply-to:references;
        bh=XPRzofz2UW/9vU0mdXC5QULoF17XY5dxtcootxY4zUI=;
        b=HttcwGkd5d44Gs0H17jz47SLQPBLmCKaYm5uk0llrT8FWCLts+W9EJTH22QUor5oa1
         Xiz8E/5j5kIYNFEKNfOYLsD0aoV+1114PvBd0YRysaLNPfNQDKf6PO64wPozbni4S+aS
         R54m9ETyUvW7Yz/H1d3PiAWAG4CRmbzMuGBJ76tAdwlGarAVfU8t4S8AoajD/QtxBazd
         QoKoJhw6Bukn//JWskMGsXmfzGiMC2t2yFk2XXDy7/0aUl1ejV/dIpHsfXlvwhDouC2I
         DUFvhCfqcmLviN+AFf458tHXS5ICaoIH40oU/JXpySqnChPwIlY9bcpKqGcWts+/i/pB
         aXEw==
X-Gm-Message-State: AGRZ1gLPz9EchRqR3c4Vgt0oN1NWm/3oFF8EqvRBS1HZcWVdtAl9B5Cz
        sdpvER3BO7It88WYXV/O59/Nca46
X-Google-Smtp-Source: 
 AJdET5eHS3g67OdwebDDlS7bSbXKQQdLktlE2LbKkGieKPfoHFKAFEm8wi3jemSJqUHFxu2rXYAdsQ==
X-Received: by 2002:a63:a441:: with SMTP id c1-v6mr43966pgp.49.1540442924885;
        Wed, 24 Oct 2018 21:48:44 -0700 (PDT)
Received: from localhost (c-73-189-176-234.hsd1.ca.comcast.net.
 [73.189.176.234])
        by smtp.gmail.com with ESMTPSA id
 o85-v6sm9982181pfk.94.2018.10.24.21.48.43
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Wed, 24 Oct 2018 21:48:43 -0700 (PDT)
From: Isaku Yamahata <isaku.yamahata@gmail.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, vkuznets@redhat.com,
        kys@microsoft.com, Tianyu.Lan@microsoft.com, yi.y.sun@intel.com,
        chao.gao@intel.com, isaku.yamahta@intel.com,
        Isaku Yamahata <isaku.yamahata@gmail.com>
Subject: [PATCH v2 2/6] x86/hyperv: use hv_do_hypercall for
 __send_ipi_mask_ex()
Date: Wed, 24 Oct 2018 21:48:27 -0700
Message-Id: 
 <7bd7ec68e1b1dcd5c073a0ba1ace2cc32c3de5ec.1540441925.git.isaku.yamahata@gmail.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

The hypercall of HVCALL_SEND_IPI_EX is not rep class. But simple class
with variable header size. The arguments to hypercall happen to be
correct. So it didn't matter so far.
But now hv_do_hypercall uses xmm fast hypercall when applicable. Use
hv_do_hypercall() instead of hv_do_rep_hypercall() for fast xmm
hypercall.

Signed-off-by: Isaku Yamahata <isaku.yamahata@gmail.com>
---
 arch/x86/hyperv/hv_apic.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 2c43e3055948..713a4e737081 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -99,6 +99,7 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 	struct hv_send_ipi_ex *ipi_arg;
 	unsigned long flags;
 	int nr_bank = 0;
+	size_t ibytes;
 	int ret = 1;
 
 	if (!(ms_hyperv.hints & HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
@@ -124,8 +125,12 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 	if (!nr_bank)
 		ipi_arg->vp_set.format = HV_GENERIC_SET_ALL;
 
-	ret = hv_do_rep_hypercall(HVCALL_SEND_IPI_EX, 0, nr_bank,
-			      ipi_arg, NULL);
+	/* see cpumask_to_vpset() and struct ipi_arg_ex */
+	ibytes = sizeof(*ipi_arg) +
+		nr_bank * sizeof(ipi_arg->vp_set.bank_contents[0]);
+	ret = hv_do_hypercall(
+		HVCALL_SEND_IPI_EX | (nr_bank << HV_HYPERCALL_VARHEAD_OFFSET),
+		ipi_arg, ibytes ,NULL, 0);
 
 ipi_mask_ex_done:
 	local_irq_restore(flags);

From patchwork Thu Oct 25 04:48:28 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Isaku Yamahata <isaku.yamahata@gmail.com>
X-Patchwork-Id: 10655409
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id D433414BD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:49 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C2CD42B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:49 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B68112B604; Thu, 25 Oct 2018 04:48:49 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 688492B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727244AbeJYNTs (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Thu, 25 Oct 2018 09:19:48 -0400
Received: from mail-pf1-f193.google.com ([209.85.210.193]:44066 "EHLO
        mail-pf1-f193.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726527AbeJYNTr (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 25 Oct 2018 09:19:47 -0400
Received: by mail-pf1-f193.google.com with SMTP id j2-v6so367154pfn.11
        for <kvm@vger.kernel.org>; Wed, 24 Oct 2018 21:48:47 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :in-reply-to:references;
        bh=c6deA05wxu1vm+kzRQn9Yw9v01GB7Ha6mKV2EhlX3/U=;
        b=AV8kv1pZ1/TqOgd/DnfzHH541sZPO8Xh/WxzWlhpVA9Ifz5rI+zkyCHNrVNkz2QK8a
         +iJK4xpkSi95mPrHTYBF7pGVvvDjsxCX47lgnRYz2qaD3BWnl3kV0wkKu2GniV1gb3JJ
         eh14eQEw0CmNGfvRFlUa4gTp50p7okYBclEisMKtpHTBJhZMEpEhu8ui12biGM1Wmjej
         3ZMxWux1JChMhsQGeUjpy3066hpqAta1t+an3L4tUoVjay+aGHGm/aObpSGTRtK4uYb+
         XnyLegv6CVMv78sqU4S5y/LZGaSyHTgB9SatgslrJkt4p9UFKrZK+SW+S0APEGWXbqdN
         z0ww==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:in-reply-to:references;
        bh=c6deA05wxu1vm+kzRQn9Yw9v01GB7Ha6mKV2EhlX3/U=;
        b=lyFZ0x3ew9bNF9LHvtLubvgl7Xe6onPwCEmLhyKb2s7Ql4P9Cr0TUyDk0TyxvtEo8p
         sD9fJApsY91xx8dvObXftO5AV5XVqhAejFlSJALGoov6taLnB2GiNQLKIWgPkmc0HcUO
         qNUotjkTkCXZWMZUKjvrmnnzCmPvzGVYJp1gEna9gYYsg+c/EFcutY9iA0FiIjff3CSO
         OoqsTDVTZcNlrl9fWS53yFJNVhWBLn8h7EwNN5iF+bus4gU6O2wHS3f9v/R/NBl/gBI5
         cYmwxpprQdVyeJgJMcWiG3HC6avxVFO+JUT5SxpDLP7sqHd8TKqmFO5m3JPa5pmLB946
         nAdQ==
X-Gm-Message-State: AGRZ1gKStgaSgttdJVsj8g11G5ScizUmm1xAUqJ6/OHpH8XFMVBjveFa
        yNOZEzo9vEVKDvTthqvRzGQgnF/e
X-Google-Smtp-Source: 
 AJdET5eO1ZL73UJDnsGp3lVrnifSYPDFQzmLwTRnc4JFN0+7ZRa5d5RgaJist+wpx4fXnF6ZFFON4Q==
X-Received: by 2002:a62:1b45:: with SMTP id b66-v6mr67256pfb.94.1540442926849;
        Wed, 24 Oct 2018 21:48:46 -0700 (PDT)
Received: from localhost (c-73-189-176-234.hsd1.ca.comcast.net.
 [73.189.176.234])
        by smtp.gmail.com with ESMTPSA id
 j19-v6sm7038281pfi.137.2018.10.24.21.48.45
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Wed, 24 Oct 2018 21:48:45 -0700 (PDT)
From: Isaku Yamahata <isaku.yamahata@gmail.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, vkuznets@redhat.com,
        kys@microsoft.com, Tianyu.Lan@microsoft.com, yi.y.sun@intel.com,
        chao.gao@intel.com, isaku.yamahta@intel.com,
        Isaku Yamahata <isaku.yamahata@gmail.com>
Subject: [PATCH v2 3/6] x86/hyperv: use hv_do_hypercall for
 flush_virtual_address_space_ex
Date: Wed, 24 Oct 2018 21:48:28 -0700
Message-Id: 
 <c896df8596d8a1be2d74d11f695cee61bf5759ff.1540441925.git.isaku.yamahata@gmail.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

The hypercall of HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX is not
rep class. But simple class with variable header size.
The arguments to hypercall happen to same with
HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX. It didn't matter so far.
But now hv_do_hypercall uses xmm fast hypercall when applicable.
Use hv_do_hypercall() instead of hv_do_rep_hypercall() for fast
xmm hypercall.

Signed-off-by: Isaku Yamahata <isaku.yamahata@gmail.com>
---
 arch/x86/hyperv/mmu.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/arch/x86/hyperv/mmu.c b/arch/x86/hyperv/mmu.c
index 41820372bb3d..e6654073a6ea 100644
--- a/arch/x86/hyperv/mmu.c
+++ b/arch/x86/hyperv/mmu.c
@@ -206,14 +206,16 @@ static u64 hyperv_flush_tlb_others_ex(const struct cpumask *cpus,
 
 	if (info->end == TLB_FLUSH_ALL) {
 		flush->flags |= HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY;
-		status = hv_do_rep_hypercall(
-			HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX,
-			0, nr_bank, flush, NULL);
+		status = hv_do_hypercall(
+			HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX |
+			(nr_bank << HV_HYPERCALL_VARHEAD_OFFSET),
+			flush, sizeof(*flush) + nr_bank * 8, NULL, 0);
 	} else if (info->end &&
 		   ((info->end - info->start)/HV_TLB_FLUSH_UNIT) > max_gvas) {
-		status = hv_do_rep_hypercall(
-			HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX,
-			0, nr_bank, flush, NULL);
+		status = hv_do_hypercall(
+			HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX |
+			(nr_bank << HV_HYPERCALL_VARHEAD_OFFSET),
+			flush, sizeof(*flush) + nr_bank * 8, NULL, 0);
 	} else {
 		gva_n = fill_gva_list(flush->gva_list, nr_bank,
 				      info->start, info->end);

From patchwork Thu Oct 25 04:48:29 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Isaku Yamahata <isaku.yamahata@gmail.com>
X-Patchwork-Id: 10655411
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id A1EFF14BD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:51 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8ED6C2B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:51 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 82B462B604; Thu, 25 Oct 2018 04:48:51 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 29E812B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727302AbeJYNTt (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Thu, 25 Oct 2018 09:19:49 -0400
Received: from mail-pl1-f193.google.com ([209.85.214.193]:33074 "EHLO
        mail-pl1-f193.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727117AbeJYNTt (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 25 Oct 2018 09:19:49 -0400
Received: by mail-pl1-f193.google.com with SMTP id x6-v6so3294842pln.0
        for <kvm@vger.kernel.org>; Wed, 24 Oct 2018 21:48:49 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :in-reply-to:references;
        bh=4awd6eJnS42mDr1F7lMcGaz5EsuquWVQ6+YffEjzZMw=;
        b=MDgR3bPqZ3UrcO8mjXz9dajPzV7JG78kuDKpuzaTxxea8ACLrqMh2lmKTh6efMns9O
         +qll27S266KEUe5nk6Or35aOryfumlMXJJoIOzBWwbSdJpSt3m4Qx1yVayKrAZh5I6I4
         qUCzvZss2ToCF1D8f8Sv4+N0wdwbpVJy++rwsgv5Z6tt89I7jfqFb7C5BX1u2zy/fz+v
         aww8dBKAL2+m8Jca3ldVXdUHxYvH9m6jN6p6vVgO7D+CUs4cc4wlFij/JCBwgBQHLBLR
         UrCep7LLEpBTwH4bJDrtfNoUw/tu6858Wy5Ot/tmA+v9jApT0R7y5tLsy9LNlbyCeO0I
         mgnA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:in-reply-to:references;
        bh=4awd6eJnS42mDr1F7lMcGaz5EsuquWVQ6+YffEjzZMw=;
        b=Iy0iLUSyAmBXEbh5NP1TPfMocbmKpdIWXJflseNCM7sp8Ja6LAd0RN4/Vsp2iHIgHD
         vHPlEbRzgDoKzfFGUYXuSYRwTPvNBM7vyR0c8NncI2WEkQM5MJOGpqYjiS1cBB2MXIBv
         NW9soNIq3ctcOMXiVOsCNAFzCRlxBedYhYG7DQAp/0ED3P7cVZ3wUS5uWtXp3Bc1QsJv
         g7/MwPl0UUMJww7G2B+7G00TPMqbcwHVQCSdrmRZ6xHlIvJ6NqpqlCyo6tsyFeFp4HjE
         MNFDi+Df3DZDtegkLbUm7eIQZ6hzaaJO/hGtUQrdd0fJvLaIFoI/qFelxHY4RwDOqqV4
         ZnZg==
X-Gm-Message-State: AGRZ1gLvG/yXeIwDrd09R7vWsetCJJ7iYloqfBYanW9szIZCZSO0dCrA
        PNeqE6ghVP+8os7B95tHHHrAnqNo
X-Google-Smtp-Source: 
 AJdET5dxFq6dQcSFyhRkF+ju/OnEaS0HtZua25LFfq6JGy9OYdoa645jnzUbUk+xgR0jvD31HxnFgg==
X-Received: by 2002:a17:902:930b:: with SMTP id
 bc11-v6mr40300plb.101.1540442928734;
        Wed, 24 Oct 2018 21:48:48 -0700 (PDT)
Received: from localhost (c-73-189-176-234.hsd1.ca.comcast.net.
 [73.189.176.234])
        by smtp.gmail.com with ESMTPSA id
 h6-v6sm7616378pfc.6.2018.10.24.21.48.47
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Wed, 24 Oct 2018 21:48:47 -0700 (PDT)
From: Isaku Yamahata <isaku.yamahata@gmail.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, vkuznets@redhat.com,
        kys@microsoft.com, Tianyu.Lan@microsoft.com, yi.y.sun@intel.com,
        chao.gao@intel.com, isaku.yamahta@intel.com,
        Isaku Yamahata <isaku.yamahata@gmail.com>
Subject: [PATCH v2 4/6] hyperv: use hv_do_hypercall instead of
 hv_do_fast_hypercall
Date: Wed, 24 Oct 2018 21:48:29 -0700
Message-Id: 
 <f661ef06d1afeddec537283e44fad61dfef9afa0.1540441925.git.isaku.yamahata@gmail.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

hv_do_hypercall can be used uniformly as code clean up because
the compiler optimizes to call hv_do_fast_hypercall directly
as typically input length is compile time constant like
sizeof(...).

Signed-off-by: Isaku Yamahata <isaku.yamahata@gmail.com>
---
 arch/x86/hyperv/hv_apic.c       | 5 +++--
 arch/x86/include/asm/mshyperv.h | 4 ++++
 drivers/hv/connection.c         | 3 ++-
 3 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 713a4e737081..63187ffaa4c4 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -168,6 +168,7 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 		goto do_ex_hypercall;
 
 	ipi_arg.vector = vector;
+	ipi_arg.reserved = 0;
 	ipi_arg.cpu_mask = 0;
 
 	for_each_cpu(cur_cpu, mask) {
@@ -185,8 +186,8 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 		__set_bit(vcpu, (unsigned long *)&ipi_arg.cpu_mask);
 	}
 
-	ret = hv_do_fast_hypercall16(HVCALL_SEND_IPI, ipi_arg.vector,
-				     ipi_arg.cpu_mask);
+	ret = hv_do_hypercall(HVCALL_SEND_IPI,
+			      &ipi_arg, sizeof(ipi_arg), NULL, 0);
 	return ((ret == 0) ? true : false);
 
 do_ex_hypercall:
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 5d8acb00ab94..9845a2420497 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -396,6 +396,10 @@ static inline u64 hv_do_hypercall(
 
 	/* fast hypercall */
 	if (output == NULL && ibytes <= 16) {
+		/* Typically ibytes is compile time constant as sizeof(...).
+		 * So the code is optimized to call
+		 * hv_do_fast_hypercall directly.
+		 */
 		u64 *i = (u64*)input;
 
 		WARN_ON((varhead_code & HV_HYPERCALL_VARHEAD_MASK) != 0);
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index ced041899456..6b1021441119 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -455,6 +455,7 @@ void vmbus_set_event(struct vmbus_channel *channel)
 
 	++channel->sig_events;
 
-	hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);
+	hv_do_hypercall(HVCALL_SIGNAL_EVENT, &channel->sig_event,
+			sizeof(channel->sig_event), NULL, 0);
 }
 EXPORT_SYMBOL_GPL(vmbus_set_event);

From patchwork Thu Oct 25 04:48:30 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Isaku Yamahata <isaku.yamahata@gmail.com>
X-Patchwork-Id: 10655413
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 0D5F3109C
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:54 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EE8AC2B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:53 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E30502B604; Thu, 25 Oct 2018 04:48:53 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5B6842B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727319AbeJYNTv (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Thu, 25 Oct 2018 09:19:51 -0400
Received: from mail-pl1-f196.google.com ([209.85.214.196]:46297 "EHLO
        mail-pl1-f196.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727117AbeJYNTv (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 25 Oct 2018 09:19:51 -0400
Received: by mail-pl1-f196.google.com with SMTP id bb7-v6so3261602plb.13
        for <kvm@vger.kernel.org>; Wed, 24 Oct 2018 21:48:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :in-reply-to:references;
        bh=bSjp3s9DLyYbgztrIYqrd3rH843Jpz7kuU78RkYsPyg=;
        b=nslAKYrFEmyC6wqbMq4R7gQni1ID2ndwldz9VIqfwpNPJJFRH6pWS6X0fjcbnZ/8MG
         sg4M9AKPh/3mRtmCtQlGyCpSchfnJwOpvEAy//AH74bildTisE17SUyV+zr556yp1jUc
         W/DQR3rXMrKxayKAo4GOlZPYrt+Z9Eb3s1Dvm8KYUiMRHXhXHefnIGxGjSuhFYA14pxf
         xWMP4NNXYWMhNNhuSjrhJDTB0cn6gNzlpiYhkju4yNjfOhvJ+srxp8ojAaccUIgDR5mC
         o5C9VieKFcJEX9NuVzI9BwJVo1b49gXvxT9Sr2LmPiRXxFTC+g7AELfSBfwV2oRyRSWG
         GdRQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:in-reply-to:references;
        bh=bSjp3s9DLyYbgztrIYqrd3rH843Jpz7kuU78RkYsPyg=;
        b=VB2KBlvxOq8keUNT6VkO34/oO/eUwxvdh+9AXbO+vcvQVuFIxRvfJAi/AgDtjM8+Ig
         AFfBEtnPmcW2uOuPdUOA3JbVxcie4PwhjezkU/ltFCM4wTqoZBHEPlg/yucI2Za7knAp
         4zv5rWZu/yMgH2BvXulTPwMHvryvQ+CFGXvc6ecX5VwxQ3kjwW8CUBecPsbeVvzDhYEq
         O+zZF+foC1RVkd+YNAO6/GCa+PYzrPOjBqmNK3BlqukRhOcl2Kvi+gY6UgZVtXmtA4sM
         HkZHu6utPgKCqJCBrETX6zM1MqRHcGLsKofFKX7RP6L6nNOWzjquBwoApufMS6tMi6CE
         nevQ==
X-Gm-Message-State: AGRZ1gKbZPZdSaTjUfpxiVWEckmz8b+TBylqcXyTrzg1TaK8qj4fFQH4
        WMgpXDrD8loZmzrSi1vRzQOnDRFF
X-Google-Smtp-Source: 
 AJdET5ePSw6EbixRYawA+xU+gU5DThisUS0MwJT3G4hpR0JTB8X78SGA5A7NJWvEhjYzPaJz4rnKAw==
X-Received: by 2002:a17:902:4222:: with SMTP id
 g31-v6mr27393pld.281.1540442930964;
        Wed, 24 Oct 2018 21:48:50 -0700 (PDT)
Received: from localhost (c-73-189-176-234.hsd1.ca.comcast.net.
 [73.189.176.234])
        by smtp.gmail.com with ESMTPSA id
 k132-v6sm12260851pga.28.2018.10.24.21.48.49
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Wed, 24 Oct 2018 21:48:50 -0700 (PDT)
From: Isaku Yamahata <isaku.yamahata@gmail.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, vkuznets@redhat.com,
        kys@microsoft.com, Tianyu.Lan@microsoft.com, yi.y.sun@intel.com,
        chao.gao@intel.com, isaku.yamahta@intel.com,
        Isaku Yamahata <isaku.yamahata@gmail.com>
Subject: [PATCH v2 5/6] x86/kvm/hyperv: implement xmm fast hypercall
Date: Wed, 24 Oct 2018 21:48:30 -0700
Message-Id: 
 <07ed3988561beabb9bd8c83c48df6f111227fe50.1540441925.git.isaku.yamahata@gmail.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

This patch makes kvm supports hyper-v xmm fast hypercall.
In order to enable guest to use it, qemu needs patch
to return appropriate feature bits to cpuid.

Signed-off-by: Isaku Yamahata <isaku.yamahata@gmail.com>
---
 arch/x86/kvm/hyperv.c | 101 ++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 81 insertions(+), 20 deletions(-)

diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
index 01d209ab5481..6408629a1b4c 100644
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@ -1269,8 +1269,30 @@ static __always_inline int get_sparse_bank_no(u64 valid_bank_mask, int bank_no)
 	return i;
 }
 
-static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,
-			    u16 rep_cnt, bool ex)
+static void kvm_hv_get_xmm_input(struct kvm_vcpu *current_vcpu,
+				 u64 rdx, u64 r8, void *input, size_t ibytes)
+{
+	u64 *tmp = input;
+	tmp[0] = rdx;
+	tmp[1] = r8;
+	memcpy((u8 *)input + 2 * 8,
+	       current_vcpu->arch.guest_fpu.state.fxsave.xmm_space,
+	       ibytes - 2 * 8);
+}
+
+static void kvm_hv_get_xmm_input_cont(
+	struct kvm_vcpu *current_vcpu,
+	void *input, size_t offset, size_t ibytes)
+{
+	u8 *xmm_space =
+		(u8 *)current_vcpu->arch.guest_fpu.state.fxsave.xmm_space;
+	memcpy(input, xmm_space + (offset - 2 * 8), ibytes);
+}
+
+static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu,
+			    bool fast, u16 varhead_size, u16 rep_cnt,
+			    u64 ingpa, u64 r8,
+			    bool ex)
 {
 	struct kvm *kvm = current_vcpu->kvm;
 	struct kvm_vcpu_hv *hv_current = &current_vcpu->arch.hyperv;
@@ -1284,8 +1306,13 @@ static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,
 	bool all_cpus;
 
 	if (!ex) {
-		if (unlikely(kvm_read_guest(kvm, ingpa, &flush, sizeof(flush))))
-			return HV_STATUS_INVALID_HYPERCALL_INPUT;
+		if (fast) {
+			kvm_hv_get_xmm_input(current_vcpu, ingpa, r8,
+					     &flush, sizeof(flush));
+		} else
+			if (unlikely(kvm_read_guest(kvm, ingpa,
+						    &flush, sizeof(flush))))
+				return HV_STATUS_INVALID_HYPERCALL_INPUT;
 
 		trace_kvm_hv_flush_tlb(flush.processor_mask,
 				       flush.address_space, flush.flags);
@@ -1293,9 +1320,16 @@ static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,
 		sparse_banks[0] = flush.processor_mask;
 		all_cpus = flush.flags & HV_FLUSH_ALL_PROCESSORS;
 	} else {
-		if (unlikely(kvm_read_guest(kvm, ingpa, &flush_ex,
-					    sizeof(flush_ex))))
-			return HV_STATUS_INVALID_HYPERCALL_INPUT;
+		if (fast) {
+			if (unlikely(sizeof(flush_ex) + varhead_size * 8 >
+				     HV_XMM_BYTE_MAX))
+				return HV_STATUS_INVALID_HYPERCALL_INPUT;
+			kvm_hv_get_xmm_input(current_vcpu, ingpa, r8,
+					     &flush_ex, sizeof(flush_ex));
+		} else
+			if (unlikely(kvm_read_guest(kvm, ingpa, &flush_ex,
+						    sizeof(flush_ex))))
+				return HV_STATUS_INVALID_HYPERCALL_INPUT;
 
 		trace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,
 					  flush_ex.hv_vp_set.format,
@@ -1312,13 +1346,20 @@ static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,
 		if (!sparse_banks_len && !all_cpus)
 			goto ret_success;
 
-		if (!all_cpus &&
-		    kvm_read_guest(kvm,
-				   ingpa + offsetof(struct hv_tlb_flush_ex,
-						    hv_vp_set.bank_contents),
-				   sparse_banks,
-				   sparse_banks_len))
-			return HV_STATUS_INVALID_HYPERCALL_INPUT;
+		if (!all_cpus) {
+			if (fast)
+				kvm_hv_get_xmm_input_cont(
+					current_vcpu, sparse_banks,
+					sizeof(flush_ex), sparse_banks_len);
+			else if (kvm_read_guest(
+					 kvm,
+					 ingpa +
+					 offsetof(struct hv_tlb_flush_ex,
+						  hv_vp_set.bank_contents),
+					 sparse_banks,
+					 sparse_banks_len))
+				return HV_STATUS_INVALID_HYPERCALL_INPUT;
+		}
 	}
 
 	cpumask_clear(&hv_current->tlb_lush);
@@ -1443,6 +1484,7 @@ int kvm_hv_hypercall(struct kvm_vcpu *vcpu)
 {
 	u64 param, ingpa, outgpa, ret = HV_STATUS_SUCCESS;
 	uint16_t code, rep_idx, rep_cnt;
+	uint16_t varhead_size;
 	bool fast, longmode, rep;
 
 	/*
@@ -1474,6 +1516,8 @@ int kvm_hv_hypercall(struct kvm_vcpu *vcpu)
 
 	code = param & 0xffff;
 	fast = !!(param & HV_HYPERCALL_FAST_BIT);
+	varhead_size = (param & HV_HYPERCALL_VARHEAD_MASK) >>
+		HV_HYPERCALL_VARHEAD_OFFSET;
 	rep_cnt = (param >> HV_HYPERCALL_REP_COMP_OFFSET) & 0xfff;
 	rep_idx = (param >> HV_HYPERCALL_REP_START_OFFSET) & 0xfff;
 	rep = !!(rep_cnt || rep_idx);
@@ -1503,6 +1547,19 @@ int kvm_hv_hypercall(struct kvm_vcpu *vcpu)
 			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 			break;
 		}
+		if (fast) {
+			u8 payloadsize = outgpa & 0xf;
+
+/* struct hv_input_post_message isn't exported
+   offsetof(struct hv_input_post_message, payload) = 16 */
+#define HV_INPUT_POST_MESSAGE_HEADER_SIZE	16
+			if (unlikely(HV_INPUT_POST_MESSAGE_HEADER_SIZE +
+				     payloadsize > HV_XMM_BYTE_MAX)) {
+				ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
+				break;
+			}
+		}
+
 		vcpu->run->exit_reason = KVM_EXIT_HYPERV;
 		vcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;
 		vcpu->run->hyperv.u.hcall.input = param;
@@ -1516,28 +1573,32 @@ int kvm_hv_hypercall(struct kvm_vcpu *vcpu)
 			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 			break;
 		}
-		ret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, false);
+		ret = kvm_hv_flush_tlb(vcpu, fast, varhead_size, rep_cnt,
+				       ingpa, outgpa, false);
 		break;
 	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:
-		if (unlikely(fast || rep)) {
+		if (unlikely(rep)) {
 			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 			break;
 		}
-		ret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, false);
+		ret = kvm_hv_flush_tlb(vcpu, fast, varhead_size, rep_cnt,
+				       ingpa, outgpa, false);
 		break;
 	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:
 		if (unlikely(fast || !rep_cnt || rep_idx)) {
 			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 			break;
 		}
-		ret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, true);
+		ret = kvm_hv_flush_tlb(vcpu, fast, varhead_size, rep_cnt,
+				       ingpa, outgpa, true);
 		break;
 	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:
-		if (unlikely(fast || rep)) {
+		if (unlikely(rep)) {
 			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 			break;
 		}
-		ret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, true);
+		ret = kvm_hv_flush_tlb(vcpu, fast, varhead_size, rep_cnt,
+				       ingpa, outgpa, true);
 		break;
 	default:
 		ret = HV_STATUS_INVALID_HYPERCALL_CODE;

From patchwork Thu Oct 25 04:48:31 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Isaku Yamahata <isaku.yamahata@gmail.com>
X-Patchwork-Id: 10655415
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 16C2D14BD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:56 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0425B2B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:56 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id ECD672B604; Thu, 25 Oct 2018 04:48:55 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-8.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 94E482B5FD
	for <patchwork-kvm@patchwork.kernel.org>;
 Thu, 25 Oct 2018 04:48:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727284AbeJYNTy (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Thu, 25 Oct 2018 09:19:54 -0400
Received: from mail-pg1-f193.google.com ([209.85.215.193]:33150 "EHLO
        mail-pg1-f193.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726527AbeJYNTy (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 25 Oct 2018 09:19:54 -0400
Received: by mail-pg1-f193.google.com with SMTP id z2-v6so3428600pgp.0
        for <kvm@vger.kernel.org>; Wed, 24 Oct 2018 21:48:53 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :in-reply-to:references;
        bh=7UMX+js/Z2eOvx42VVyaYLEqMd2WCQ2iQq+FMNR9jL0=;
        b=WpRHhphZI/yXdwxga+MXvu9yV3gAQPbl0RUFxGy9mwh5Zj7trrXD5r5luA0JgQaQH9
         wdOIcYDtTRkSadQ4L0hMqY78XtX739VWr2MjX4O7oSg3OIZ1cSkRORLuTK8e9neSW3Rd
         fN5CwJ2+g/WtQwLaRIOVZgceusjwLU7Df9FbqOGzxTFiWJDkqpNw4Xv499x9DCKFQo7W
         wQ9cNGJHt0MPeuOstnap1MP2wbShgOs7Z/5I/Mf0dit/YiJq3M05TX9sqzitukgP+gOX
         SmVXtIjD4QIgnstlWRlXRZFZ/gwaDMyDCnx2orvTyqiPVTMiYc/e1KQKsoOCVXNIEA8R
         iA1Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:in-reply-to:references;
        bh=7UMX+js/Z2eOvx42VVyaYLEqMd2WCQ2iQq+FMNR9jL0=;
        b=I8mYPfb3NU6bthBcyQ9I6W9gTwZxsnW3qf5e4xAwdkJaJMUBPHm0CfTJU4yhoevWQe
         JfIhnUjPMFT7odehjfoyziDd8BXAita+Y2cLXIVhwMIUy/jGDh1FPNNDPFOGZs8JlydF
         N64ch8yVFcuwEUAI1kYGcBdh3Bgyj2qlj7DKg5VXvjXbiBJYbLVtzHBaIzL8eLKTdraP
         +ATytpUso2in2OOWk/qKPEQn4deEm+sm4TRRYrjJ3/pMpbcPmWgPYsLqxGlPDc2rC+Vd
         7W2EgROej5/dz6qHXQiXGQQuhkpZCILXRgSwZQg2m2fOBXTnnN/EeV0avRIr1PXz8bf6
         arag==
X-Gm-Message-State: AGRZ1gL3kYLm431F9lgazjdZAON2GiFy/RpwJNpwT0C3K8gQSXYtuuD6
        ZyeMFMMjr5c+MZeY6nEkae+0Qs1T
X-Google-Smtp-Source: 
 AJdET5ekDLJ4eQD7ewnjo/DvkNRYYUUpXyfs7RRujGtoSr5XMvQma6sRprTUPfNjvOMHgoeqQAvP5A==
X-Received: by 2002:a62:154f:: with SMTP id 76-v6mr58497pfv.178.1540442932872;
        Wed, 24 Oct 2018 21:48:52 -0700 (PDT)
Received: from localhost (c-73-189-176-234.hsd1.ca.comcast.net.
 [73.189.176.234])
        by smtp.gmail.com with ESMTPSA id
 72-v6sm14272706pfr.115.2018.10.24.21.48.51
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Wed, 24 Oct 2018 21:48:51 -0700 (PDT)
From: Isaku Yamahata <isaku.yamahata@gmail.com>
To: kvm@vger.kernel.org
Cc: pbonzini@redhat.com, rkrcmar@redhat.com, vkuznets@redhat.com,
        kys@microsoft.com, Tianyu.Lan@microsoft.com, yi.y.sun@intel.com,
        chao.gao@intel.com, isaku.yamahta@intel.com,
        Isaku Yamahata <isaku.yamahata@gmail.com>
Subject: [PATCH v2 6/6] local: hyperv: test ex hypercall
Date: Wed, 24 Oct 2018 21:48:31 -0700
Message-Id: 
 <6342c755832858432c8a5e5948710d7d3250962a.1540441925.git.isaku.yamahata@gmail.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
In-Reply-To: <cover.1540441925.git.isaku.yamahata@gmail.com>
References: <cover.1540441925.git.isaku.yamahata@gmail.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

This patch is just to test ex hypercall locally. Not for merge.

Signed-off-by: Isaku Yamahata <isaku.yamahata@gmail.com>
---
 arch/x86/hyperv/hv_apic.c | 2 ++
 arch/x86/hyperv/mmu.c     | 6 +++++-
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/arch/x86/hyperv/hv_apic.c b/arch/x86/hyperv/hv_apic.c
index 63187ffaa4c4..8fe7a1a801fa 100644
--- a/arch/x86/hyperv/hv_apic.c
+++ b/arch/x86/hyperv/hv_apic.c
@@ -139,6 +139,7 @@ static bool __send_ipi_mask_ex(const struct cpumask *mask, int vector)
 
 static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 {
+#if 0
 	int cur_cpu, vcpu;
 	struct hv_send_ipi ipi_arg;
 	int ret = 1;
@@ -191,6 +192,7 @@ static bool __send_ipi_mask(const struct cpumask *mask, int vector)
 	return ((ret == 0) ? true : false);
 
 do_ex_hypercall:
+#endif
 	return __send_ipi_mask_ex(mask, vector);
 }
 
diff --git a/arch/x86/hyperv/mmu.c b/arch/x86/hyperv/mmu.c
index e6654073a6ea..65d3aa90b54f 100644
--- a/arch/x86/hyperv/mmu.c
+++ b/arch/x86/hyperv/mmu.c
@@ -96,6 +96,7 @@ static void hyperv_flush_tlb_others(const struct cpumask *cpus,
 	if (cpumask_equal(cpus, cpu_present_mask)) {
 		flush->flags |= HV_FLUSH_ALL_PROCESSORS;
 	} else {
+#if 0
 		/*
 		 * From the supplied CPU set we need to figure out if we can get
 		 * away with cheaper HVCALL_FLUSH_VIRTUAL_ADDRESS_{LIST,SPACE}
@@ -123,8 +124,10 @@ static void hyperv_flush_tlb_others(const struct cpumask *cpus,
 			__set_bit(vcpu, (unsigned long *)
 				  &flush->processor_mask);
 		}
+#endif
 	}
 
+#if 0
 	/*
 	 * We can flush not more than max_gvas with one hypercall. Flush the
 	 * whole address space if we were asked to do more.
@@ -148,9 +151,10 @@ static void hyperv_flush_tlb_others(const struct cpumask *cpus,
 	goto check_status;
 
 do_ex_hypercall:
+#endif
 	status = hyperv_flush_tlb_others_ex(cpus, info);
 
-check_status:
+// check_status:
 	local_irq_restore(flags);
 
 	if (!(status & HV_HYPERCALL_RESULT_MASK))
